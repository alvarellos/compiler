
//----------------------------------------------------
// The following code was generated by CUP v0.11a beta 20060608
// Mon Jun 12 22:36:35 CEST 2017
//----------------------------------------------------

package compiler.syntax;

import java_cup.runtime.Symbol;
import java.util.*;
import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;
import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;
import java.util.Map.Entry;
import compiler.intermediate.Factory.*;
import compiler.syntax.Expresion.*;
import compiler.zExtra.*;

/** CUP v0.11a beta 20060608 generated parser.
  * @version Mon Jun 12 22:36:35 CEST 2017
  */
public class parser extends java_cup.runtime.lr_parser {

  /** Default constructor. */
  public parser() {super();}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\132\000\002\002\004\000\002\044\002\000\002\002" +
    "\004\000\002\045\002\000\002\003\007\000\002\005\004" +
    "\000\002\005\002\000\002\004\006\000\002\012\004\000" +
    "\002\012\002\000\002\006\007\000\002\007\003\000\002" +
    "\007\004\000\002\010\005\000\002\010\005\000\002\010" +
    "\005\000\002\010\005\000\002\011\005\000\002\011\005" +
    "\000\002\017\004\000\002\017\002\000\002\013\004\000" +
    "\002\013\004\000\002\014\004\000\002\014\005\000\002" +
    "\014\005\000\002\014\006\000\002\015\005\000\002\015" +
    "\004\000\002\015\005\000\002\015\006\000\002\016\004" +
    "\000\002\016\004\000\002\032\004\000\002\032\003\000" +
    "\002\046\002\000\002\026\007\000\002\047\002\000\002" +
    "\026\007\000\002\050\002\000\002\031\010\000\002\051" +
    "\002\000\002\031\007\000\002\027\005\000\002\030\006" +
    "\000\002\030\004\000\002\052\002\000\002\053\002\000" +
    "\002\033\013\000\002\034\005\000\002\020\003\000\002" +
    "\020\003\000\002\021\005\000\002\021\005\000\002\021" +
    "\005\000\002\021\005\000\002\021\005\000\002\021\003" +
    "\000\002\021\003\000\002\021\003\000\002\021\003\000" +
    "\002\022\005\000\002\022\005\000\002\023\005\000\002" +
    "\023\007\000\002\024\005\000\002\024\006\000\002\025" +
    "\003\000\002\025\005\000\002\054\002\000\002\055\002" +
    "\000\002\041\011\000\002\043\007\000\002\043\011\000" +
    "\002\035\015\000\002\035\015\000\002\036\007\000\002" +
    "\036\006\000\002\037\007\000\002\042\004\000\002\042" +
    "\002\000\002\040\003\000\002\040\003\000\002\040\003" +
    "\000\002\040\003\000\002\040\003\000\002\040\004\000" +
    "\002\040\004\000\002\040\004\000\002\040\005" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\311\000\014\004\000\011\000\016\000\017\000\020" +
    "\000\001\002\000\004\002\313\001\002\000\014\004\ufffe" +
    "\011\ufffe\016\ufffe\017\ufffe\020\ufffe\001\002\000\014\004" +
    "\010\011\ufffb\016\ufffb\017\ufffb\020\ufffb\001\002\000\004" +
    "\002\uffff\001\002\000\004\020\310\001\002\000\012\011" +
    "\ufff8\016\016\017\ufff8\020\ufff8\001\002\000\014\004\010" +
    "\011\ufffb\016\ufffb\017\ufffb\020\ufffb\001\002\000\012\011" +
    "\ufffc\016\ufffc\017\ufffc\020\ufffc\001\002\000\010\011\uffed" +
    "\017\uffed\020\uffed\001\002\000\030\007\ufff8\010\ufff8\011" +
    "\ufff8\013\ufff8\014\ufff8\015\ufff8\016\016\017\ufff8\020\ufff8" +
    "\026\ufff8\027\ufff8\001\002\000\004\020\017\001\002\000" +
    "\004\026\020\001\002\000\006\011\024\020\021\001\002" +
    "\000\004\020\036\001\002\000\010\011\024\020\021\027" +
    "\034\001\002\000\010\011\ufff6\020\ufff6\027\ufff6\001\002" +
    "\000\004\020\025\001\002\000\006\023\027\034\026\001" +
    "\002\000\004\020\031\001\002\000\010\011\ufff4\020\ufff4" +
    "\027\ufff4\001\002\000\010\011\ufff2\020\ufff2\027\ufff2\001" +
    "\002\000\006\023\032\034\026\001\002\000\010\011\uffef" +
    "\020\uffef\027\uffef\001\002\000\010\011\ufff0\020\ufff0\027" +
    "\ufff0\001\002\000\030\007\ufff7\010\ufff7\011\ufff7\013\ufff7" +
    "\014\ufff7\015\ufff7\016\ufff7\017\ufff7\020\ufff7\026\ufff7\027" +
    "\ufff7\001\002\000\010\011\ufff5\020\ufff5\027\ufff5\001\002" +
    "\000\006\023\037\034\026\001\002\000\010\011\ufff3\020" +
    "\ufff3\027\ufff3\001\002\000\010\011\ufff1\020\ufff1\027\ufff1" +
    "\001\002\000\026\007\ufff9\010\ufff9\011\ufff9\013\ufff9\014" +
    "\ufff9\015\ufff9\017\ufff9\020\ufff9\026\ufff9\027\ufff9\001\002" +
    "\000\010\011\051\017\050\020\043\001\002\000\004\020" +
    "\240\001\002\000\004\002\uffdf\001\002\000\004\002\ufffd" +
    "\001\002\000\026\007\uffee\010\uffee\011\uffee\013\uffee\014" +
    "\uffee\015\uffee\017\uffee\020\uffee\026\uffee\027\uffee\001\002" +
    "\000\006\011\306\017\050\001\002\000\006\012\267\020" +
    "\266\001\002\000\004\020\052\001\002\000\012\022\061" +
    "\023\056\024\uffdc\034\055\001\002\000\026\007\uffeb\010" +
    "\uffeb\011\uffeb\013\uffeb\014\uffeb\015\uffeb\017\uffeb\020\uffeb" +
    "\026\uffeb\027\uffeb\001\002\000\004\024\074\001\002\000" +
    "\004\020\070\001\002\000\026\007\uffea\010\uffea\011\uffea" +
    "\013\uffea\014\uffea\015\uffea\017\uffea\020\uffea\026\uffea\027" +
    "\uffea\001\002\000\006\023\065\034\055\001\002\000\004" +
    "\023\064\001\002\000\006\020\063\021\062\001\002\000" +
    "\006\023\uffe2\034\uffe2\001\002\000\006\023\uffe1\034\uffe1" +
    "\001\002\000\026\007\uffe9\010\uffe9\011\uffe9\013\uffe9\014" +
    "\uffe9\015\uffe9\017\uffe9\020\uffe9\026\uffe9\027\uffe9\001\002" +
    "\000\026\007\uffe8\010\uffe8\011\uffe8\013\uffe8\014\uffe8\015" +
    "\uffe8\017\uffe8\020\uffe8\026\uffe8\027\uffe8\001\002\000\004" +
    "\023\067\001\002\000\026\007\uffe7\010\uffe7\011\uffe7\013" +
    "\uffe7\014\uffe7\015\uffe7\017\uffe7\020\uffe7\026\uffe7\027\uffe7" +
    "\001\002\000\010\022\061\023\uffe5\034\055\001\002\000" +
    "\006\023\uffe4\034\055\001\002\000\004\023\uffe6\001\002" +
    "\000\004\023\uffe3\001\002\000\006\011\100\025\075\001" +
    "\002\000\004\026\uffd8\001\002\000\006\011\uffdb\017\uffdb" +
    "\001\002\000\004\025\104\001\002\000\004\020\101\001" +
    "\002\000\006\025\uffd4\034\102\001\002\000\004\011\100" +
    "\001\002\000\004\025\uffd5\001\002\000\004\026\105\001" +
    "\002\000\026\007\uffda\010\uffda\011\uffda\013\uffda\014\uffda" +
    "\015\uffda\016\uffda\020\uffda\026\uffda\027\uffda\001\002\000" +
    "\026\007\ufff8\010\ufff8\011\ufff8\013\ufff8\014\ufff8\015\ufff8" +
    "\016\016\020\ufff8\026\ufff8\027\ufff8\001\002\000\024\007" +
    "\uffed\010\uffed\011\uffed\013\uffed\014\uffed\015\uffed\020\uffed" +
    "\026\uffed\027\uffed\001\002\000\004\027\111\001\002\000" +
    "\006\011\uffd9\017\uffd9\001\002\000\024\007\133\010\122" +
    "\011\116\013\124\014\121\015\120\020\123\026\132\027" +
    "\uffb1\001\002\000\024\006\uffad\007\uffad\010\uffad\013\uffad" +
    "\014\uffad\015\uffad\020\uffad\026\uffad\027\uffad\001\002\000" +
    "\004\022\176\001\002\000\024\006\uffb0\007\uffb0\010\uffb0" +
    "\013\uffb0\014\uffb0\015\uffb0\020\uffb0\026\uffb0\027\uffb0\001" +
    "\002\000\004\020\240\001\002\000\004\023\261\001\002" +
    "\000\012\020\167\021\141\023\257\024\145\001\002\000" +
    "\004\024\250\001\002\000\004\024\242\001\002\000\012" +
    "\020\240\022\172\024\162\030\161\001\002\000\004\024" +
    "\234\001\002\000\022\007\133\010\122\013\124\014\121" +
    "\015\120\020\213\026\132\027\uffb1\001\002\000\004\023" +
    "\232\001\002\000\004\027\uffd6\001\002\000\024\006\uffaf" +
    "\007\uffaf\010\uffaf\013\uffaf\014\uffaf\015\uffaf\020\uffaf\026" +
    "\uffaf\027\uffaf\001\002\000\024\006\uffae\007\uffae\010\uffae" +
    "\013\uffae\014\uffae\015\uffae\020\uffae\026\uffae\027\uffae\001" +
    "\002\000\026\007\uffbc\010\uffbc\011\uffbc\013\uffbc\014\uffbc" +
    "\015\uffbc\016\uffbc\020\uffbc\026\uffbc\027\uffbc\001\002\000" +
    "\004\024\135\001\002\000\024\006\uffac\007\uffac\010\uffac" +
    "\013\uffac\014\uffac\015\uffac\020\uffac\026\uffac\027\uffac\001" +
    "\002\000\004\020\136\001\002\000\006\022\214\030\161" +
    "\001\002\000\004\022\140\001\002\000\010\020\143\021" +
    "\141\024\145\001\002\000\020\005\uffc7\023\uffc7\025\uffc7" +
    "\031\uffc7\032\uffc7\033\uffc7\034\uffc7\001\002\000\014\005" +
    "\152\023\204\031\151\032\154\033\153\001\002\000\024" +
    "\005\uffc8\023\uffc8\024\162\025\uffc8\030\161\031\uffc8\032" +
    "\uffc8\033\uffc8\034\uffc8\001\002\000\020\005\uffc5\023\uffc5" +
    "\025\uffc5\031\uffc5\032\uffc5\033\uffc5\034\uffc5\001\002\000" +
    "\010\020\143\021\141\024\145\001\002\000\020\005\uffc6" +
    "\023\uffc6\025\uffc6\031\uffc6\032\uffc6\033\uffc6\034\uffc6\001" +
    "\002\000\014\005\152\025\150\031\151\032\154\033\153" +
    "\001\002\000\020\005\uffc9\023\uffc9\025\uffc9\031\uffc9\032" +
    "\uffc9\033\uffc9\034\uffc9\001\002\000\010\020\143\021\141" +
    "\024\145\001\002\000\010\020\143\021\141\024\145\001" +
    "\002\000\010\020\143\021\141\024\145\001\002\000\010" +
    "\020\143\021\141\024\145\001\002\000\020\005\152\023" +
    "\uffcb\025\uffcb\031\uffcb\032\uffcb\033\uffcb\034\uffcb\001\002" +
    "\000\020\005\152\023\uffcc\025\uffcc\031\151\032\154\033" +
    "\uffcc\034\uffcc\001\002\000\020\005\uffcd\023\uffcd\025\uffcd" +
    "\031\uffcd\032\uffcd\033\uffcd\034\uffcd\001\002\000\020\005" +
    "\152\023\uffca\025\uffca\031\uffca\032\154\033\uffca\034\uffca" +
    "\001\002\000\004\020\201\001\002\000\012\020\167\021" +
    "\141\024\145\025\164\001\002\000\004\025\200\001\002" +
    "\000\020\005\uffc0\023\uffc0\025\uffc0\031\uffc0\032\uffc0\033" +
    "\uffc0\034\uffc0\001\002\000\022\005\uffc5\022\176\023\uffc5" +
    "\025\uffc5\031\uffc5\032\uffc5\033\uffc5\034\uffc5\001\002\000" +
    "\006\025\uffbe\034\174\001\002\000\026\005\uffc8\022\172" +
    "\023\uffc8\024\162\025\uffc8\030\161\031\uffc8\032\uffc8\033" +
    "\uffc8\034\uffc8\001\002\000\020\005\152\023\uffcf\025\uffcf" +
    "\031\151\032\154\033\153\034\uffcf\001\002\000\010\023" +
    "\uffce\025\uffce\034\uffce\001\002\000\010\020\143\021\141" +
    "\024\145\001\002\000\020\005\152\023\uffc4\025\uffc4\031" +
    "\151\032\154\033\153\034\uffc4\001\002\000\010\020\167" +
    "\021\141\024\145\001\002\000\004\025\uffbd\001\002\000" +
    "\010\020\143\021\141\024\145\001\002\000\020\005\152" +
    "\023\uffc3\025\uffc3\031\151\032\154\033\153\034\uffc3\001" +
    "\002\000\020\005\uffbf\023\uffbf\025\uffbf\031\uffbf\032\uffbf" +
    "\033\uffbf\034\uffbf\001\002\000\024\005\uffc2\022\uffc2\023" +
    "\uffc2\025\uffc2\030\202\031\uffc2\032\uffc2\033\uffc2\034\uffc2" +
    "\001\002\000\004\020\203\001\002\000\022\005\uffc1\022" +
    "\uffc1\023\uffc1\025\uffc1\031\uffc1\032\uffc1\033\uffc1\034\uffc1" +
    "\001\002\000\010\020\143\021\141\024\145\001\002\000" +
    "\014\005\152\023\206\031\151\032\154\033\153\001\002" +
    "\000\004\020\207\001\002\000\006\022\172\030\161\001" +
    "\002\000\004\025\211\001\002\000\020\007\133\010\122" +
    "\013\124\014\121\015\120\020\213\026\132\001\002\000" +
    "\024\006\uffb6\007\uffb6\010\uffb6\013\uffb6\014\uffb6\015\uffb6" +
    "\020\uffb6\026\uffb6\027\uffb6\001\002\000\010\022\172\024" +
    "\162\030\161\001\002\000\010\020\143\021\141\024\145" +
    "\001\002\000\014\005\152\023\216\031\151\032\154\033" +
    "\153\001\002\000\010\020\143\021\141\024\145\001\002" +
    "\000\014\005\152\023\220\031\151\032\154\033\153\001" +
    "\002\000\004\020\207\001\002\000\004\025\222\001\002" +
    "\000\020\007\133\010\122\013\124\014\121\015\120\020" +
    "\213\026\132\001\002\000\024\006\uffb7\007\uffb7\010\uffb7" +
    "\013\uffb7\014\uffb7\015\uffb7\020\uffb7\026\uffb7\027\uffb7\001" +
    "\002\000\026\007\ufff8\010\ufff8\011\ufff8\013\ufff8\014\ufff8" +
    "\015\ufff8\016\016\020\ufff8\026\ufff8\027\ufff8\001\002\000" +
    "\024\007\uffed\010\uffed\011\uffed\013\uffed\014\uffed\015\uffed" +
    "\020\uffed\026\uffed\027\uffed\001\002\000\024\007\133\010" +
    "\122\011\116\013\124\014\121\015\120\020\123\026\132" +
    "\027\uffb1\001\002\000\004\027\uffbb\001\002\000\004\027" +
    "\231\001\002\000\024\006\uffba\007\uffba\010\uffba\013\uffba" +
    "\014\uffba\015\uffba\020\uffba\026\uffba\027\uffba\001\002\000" +
    "\024\006\uffaa\007\uffaa\010\uffaa\013\uffaa\014\uffaa\015\uffaa" +
    "\020\uffaa\026\uffaa\027\uffaa\001\002\000\004\027\uffb2\001" +
    "\002\000\004\035\235\001\002\000\004\025\236\001\002" +
    "\000\004\023\237\001\002\000\024\006\uffb3\007\uffb3\010" +
    "\uffb3\013\uffb3\014\uffb3\015\uffb3\020\uffb3\026\uffb3\027\uffb3" +
    "\001\002\000\010\022\061\023\056\034\055\001\002\000" +
    "\026\007\uffec\010\uffec\011\uffec\013\uffec\014\uffec\015\uffec" +
    "\017\uffec\020\uffec\026\uffec\027\uffec\001\002\000\010\020" +
    "\167\021\141\024\145\001\002\000\004\025\244\001\002" +
    "\000\020\007\133\010\122\013\124\014\121\015\120\020" +
    "\213\026\132\001\002\000\024\006\246\007\uffb9\010\uffb9" +
    "\013\uffb9\014\uffb9\015\uffb9\020\uffb9\026\uffb9\027\uffb9\001" +
    "\002\000\020\007\133\010\122\013\124\014\121\015\120" +
    "\020\213\026\132\001\002\000\024\006\uffb8\007\uffb8\010" +
    "\uffb8\013\uffb8\014\uffb8\015\uffb8\020\uffb8\026\uffb8\027\uffb8" +
    "\001\002\000\012\020\167\021\141\024\145\025\251\001" +
    "\002\000\004\023\255\001\002\000\004\025\253\001\002" +
    "\000\004\023\254\001\002\000\024\006\uffb5\007\uffb5\010" +
    "\uffb5\013\uffb5\014\uffb5\015\uffb5\020\uffb5\026\uffb5\027\uffb5" +
    "\001\002\000\024\006\uffb4\007\uffb4\010\uffb4\013\uffb4\014" +
    "\uffb4\015\uffb4\020\uffb4\026\uffb4\027\uffb4\001\002\000\004" +
    "\023\260\001\002\000\024\006\uffa9\007\uffa9\010\uffa9\013" +
    "\uffa9\014\uffa9\015\uffa9\020\uffa9\026\uffa9\027\uffa9\001\002" +
    "\000\024\006\uffa8\007\uffa8\010\uffa8\013\uffa8\014\uffa8\015" +
    "\uffa8\020\uffa8\026\uffa8\027\uffa8\001\002\000\024\006\uffab" +
    "\007\uffab\010\uffab\013\uffab\014\uffab\015\uffab\020\uffab\026" +
    "\uffab\027\uffab\001\002\000\004\026\263\001\002\000\026" +
    "\007\ufff8\010\ufff8\011\ufff8\013\ufff8\014\ufff8\015\ufff8\016" +
    "\016\020\ufff8\026\ufff8\027\ufff8\001\002\000\004\027\265" +
    "\001\002\000\006\011\uffd7\017\uffd7\001\002\000\004\024" +
    "\uffde\001\002\000\004\024\270\001\002\000\004\025\uffd3" +
    "\001\002\000\004\025\272\001\002\000\004\026\273\001" +
    "\002\000\026\007\ufff8\010\ufff8\011\ufff8\013\ufff8\014\ufff8" +
    "\015\ufff8\016\016\020\ufff8\026\ufff8\027\ufff8\001\002\000" +
    "\004\027\uffd2\001\002\000\024\007\uffed\010\uffed\011\uffed" +
    "\013\uffed\014\uffed\015\uffed\020\uffed\026\uffed\027\uffed\001" +
    "\002\000\024\007\133\010\122\011\116\013\124\014\121" +
    "\015\120\020\123\026\132\027\uffb1\001\002\000\004\027" +
    "\uffd0\001\002\000\004\027\301\001\002\000\004\002\uffd1" +
    "\001\002\000\004\024\303\001\002\000\006\011\100\025" +
    "\075\001\002\000\006\011\uffdd\017\uffdd\001\002\000\004" +
    "\002\uffe0\001\002\000\004\020\307\001\002\000\004\024" +
    "\uffdc\001\002\000\004\021\311\001\002\000\004\023\312" +
    "\001\002\000\014\004\ufffa\011\ufffa\016\ufffa\017\ufffa\020" +
    "\ufffa\001\002\000\004\002\001\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\311\000\006\002\003\044\004\001\001\000\002\001" +
    "\001\000\006\003\006\045\005\001\001\000\006\004\011" +
    "\005\010\001\001\000\002\001\001\000\002\001\001\000" +
    "\006\006\014\012\013\001\001\000\006\004\011\005\012" +
    "\001\001\000\002\001\001\000\004\017\041\001\001\000" +
    "\006\006\014\012\040\001\001\000\002\001\001\000\002" +
    "\001\001\000\006\007\021\010\022\001\001\000\002\001" +
    "\001\000\004\010\034\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\011\027\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\011\032\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\011\037\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\012\013\045\026" +
    "\046\032\044\033\043\001\001\000\004\014\240\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\010\026\046\032\304\033\043\001\001\000\002\001\001" +
    "\000\004\014\052\001\001\000\010\015\057\016\056\047" +
    "\053\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\015\065\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\006\015\071\016\070\001\001" +
    "\000\004\015\072\001\001\000\002\001\001\000\002\001" +
    "\001\000\006\030\076\031\075\001\001\000\004\051\261" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\030\102\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\050\105\001\001\000" +
    "\010\006\014\012\106\027\107\001\001\000\004\017\111" +
    "\001\001\000\002\001\001\000\002\001\001\000\030\013" +
    "\045\022\116\023\113\024\125\035\127\036\112\037\133" +
    "\040\124\041\114\042\126\043\130\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\014\052" +
    "\001\001\000\002\001\001\000\014\020\255\021\167\022" +
    "\170\023\164\024\145\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\014\240\001\001\000\002\001\001\000" +
    "\026\022\116\023\113\024\125\035\127\036\112\037\133" +
    "\040\124\041\114\042\232\043\130\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\054\223\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\023\136\001\001\000\002\001\001\000\002" +
    "\001\001\000\010\021\141\023\143\024\145\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\010\021\146\023\143\024\145\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\010" +
    "\021\157\023\143\024\145\001\001\000\010\021\156\023" +
    "\143\024\145\001\001\000\010\021\155\023\143\024\145" +
    "\001\001\000\010\021\154\023\143\024\145\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\016\020\165\021\167\022" +
    "\170\023\164\024\145\025\162\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\010" +
    "\021\172\023\143\024\145\001\001\000\002\001\001\000" +
    "\016\020\165\021\167\022\170\023\164\024\145\025\174" +
    "\001\001\000\002\001\001\000\010\021\176\023\143\024" +
    "\145\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\010\021" +
    "\204\023\143\024\145\001\001\000\002\001\001\000\006" +
    "\022\207\023\113\001\001\000\002\001\001\000\002\001" +
    "\001\000\024\022\116\023\113\024\125\035\127\036\112" +
    "\037\133\040\211\041\114\043\130\001\001\000\002\001" +
    "\001\000\002\001\001\000\010\021\214\023\143\024\145" +
    "\001\001\000\002\001\001\000\010\021\216\023\143\024" +
    "\145\001\001\000\002\001\001\000\006\022\220\023\113" +
    "\001\001\000\002\001\001\000\024\022\116\023\113\024" +
    "\125\035\127\036\112\037\133\040\222\041\114\043\130" +
    "\001\001\000\002\001\001\000\006\006\014\012\224\001" +
    "\001\000\004\017\225\001\001\000\030\013\045\022\116" +
    "\023\113\024\125\035\127\036\112\037\133\040\124\041" +
    "\114\042\226\043\130\001\001\000\004\055\227\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\006\015\057\016\056\001" +
    "\001\000\002\001\001\000\014\020\242\021\167\022\170" +
    "\023\164\024\145\001\001\000\002\001\001\000\024\022" +
    "\116\023\113\024\125\035\127\036\112\037\133\040\244" +
    "\041\114\043\130\001\001\000\002\001\001\000\024\022" +
    "\116\023\113\024\125\035\127\036\112\037\133\040\246" +
    "\041\114\043\130\001\001\000\002\001\001\000\014\020" +
    "\251\021\167\022\170\023\164\024\145\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\010\006\014\012\106\027\263\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\046\301\001\001\000\002\001" +
    "\001\000\004\052\270\001\001\000\002\001\001\000\002" +
    "\001\001\000\010\006\014\012\274\034\273\001\001\000" +
    "\004\053\277\001\001\000\004\017\275\001\001\000\030" +
    "\013\045\022\116\023\113\024\125\035\127\036\112\037" +
    "\133\040\124\041\114\042\276\043\130\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\006\030\076\031\303\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\047\053\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$parser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}



	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
	
	public void syntax_error(Symbol symbol)
	{ 
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);	    
	}
		
	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	}

}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$parser$actions {


	
	SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
	ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
	FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();


  // Nuevo 
	// Código final 

		// Cadenas 
	List cadenas = new ArrayList();

	// Desplazamiento Campos Registro
	int desplazaCampoReg = 5;

  // Anidamiento de registro

  int anidamientoReg       = -19; // Clave
  int desplazaCampoAnidado =  -19; // Valor

  // Map<Clave, Valor>
  HashMap<Integer, Integer> diccionario = new HashMap<Integer, Integer>();

	// Desplazamiento ambito
	HashMap desplazaScope = new HashMap();

  // Contador de sentencia RETURN
  int retorno = 0;

	// fin Nuevo código final


  // Se instancian objetos factoría para la gestión de Símbolos y Tipos.
  TablaSimbolos tablaSimbolos = new TablaSimbolos(scopeManager);
  TablaTipos    tablaTipos    = new TablaTipos(scopeManager);

  // ----------------------------------------------------------------
  // Este código se puede incluir si se quiere
  // prescindir de los mensajes de semanticErrorManager
  // y obtener solamente los mensajes de SemanticError
  // (hay que quitar tambien la llamada a semanticErrorManager) 

  // Wrapper para construir la salida de los errores semánticos.
  public void semanticFatalError(String errorMessage, Token token)
  {
    // Más información en API es.uned.lsi.compiler.semantic.SemanticError
    SemanticError sError = new SemanticError(errorMessage);
    sError.setLine(token.getLine());
    sError.setColumn(token.getColumn());
    semanticErrorManager.semanticFatalError(sError);
  }

  // ----------------------------------------------------------------



  private final parser parser;

  /** Constructor */
  CUP$parser$actions(parser parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$parser$do_action(
    int                        CUP$parser$act_num,
    java_cup.runtime.lr_parser CUP$parser$parser,
    java.util.Stack            CUP$parser$stack,
    int                        CUP$parser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$parser$result;

      /* select the action based on the action number */
      switch (CUP$parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // sentencia ::= RETURN expresion SEMICOLON 
            {
              Sentencia RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Expresion exp = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		

          int contRetornos = retorno + 1;

          String nombre = "return" + String.valueOf(contRetornos);
          TypeInteger tipo = new TypeInteger(scopeManager.getCurrentScope());
          ScopeIF ambito = scopeManager.getCurrentScope();
          SymbolReturn retornoFuncion = new SymbolReturn(ambito, nombre, tipo);
          // tablaSimbolos.addSymbol(retornoFuncion);

          IntermedioSentenciaRETURN sentRet = new IntermedioSentenciaRETURN(exp, retornoFuncion);
          sentRet.codigoIntermedio();
          RESULT = sentRet;

         
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",30, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // sentencia ::= RETURN SEMICOLON 
            {
              Sentencia RESULT =null;
		
          IntermedioSentenciaRETURN sent = new IntermedioSentenciaRETURN();
          RESULT = sent;
         
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",30, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // sentencia ::= invFunc SEMICOLON 
            {
              Sentencia RESULT =null;
		int llamadaSubPleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int llamadaSubPright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		LlamadaSubprograma llamadaSubP = (LlamadaSubprograma)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 

      // No se permite que la función invocada devuelva un tipo INT en sentencias

        Token id         = llamadaSubP.getId();
        String nombre    = id.getLexema();
        SymbolIF simbolo = scopeManager.searchSymbol(nombre);
      //  TypeIF tipoRetorno = scopeManager.searchType(id.getLexema());
        
        SymbolFunction simboloFuncion = (SymbolFunction) simbolo;

        if (simboloFuncion.get_devuelve_tipo() instanceof TypeInteger)
        {semanticErrorManager.semanticFatalError(SemanticErrors.Retorno_de_funcion_incorrecto_2, id); }

        // Código Intermedio
        // IntermedioExpresionLlamadaSubprograma expLlSub = new IntermedioExpresionLlamadaSubprograma(llamadaSubP);
        IntermedioExpresionLlamadaSubprograma expLlSub = new IntermedioExpresionLlamadaSubprograma(simboloFuncion, llamadaSubP);
          expLlSub.codigoIntermedio();
                   RESULT = expLlSub;  

         
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",30, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // sentencia ::= expAsig SEMICOLON 
            {
              Sentencia RESULT =null;
		int expAsignacionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int expAsignacionright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		ExpresionAsignacion expAsignacion = (ExpresionAsignacion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 RESULT = expAsignacion; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",30, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // sentencia ::= sentSalidaCadena 
            {
              Sentencia RESULT =null;
		int writeCadenaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int writeCadenaright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		SentenciaSalidaCadena writeCadena = (SentenciaSalidaCadena)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = writeCadena; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",30, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // sentencia ::= sentSalidaValor 
            {
              Sentencia RESULT =null;
		int writeValorleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int writeValorright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		SentenciaSalidaValor writeValor = (SentenciaSalidaValor)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = writeValor;  
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",30, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // sentencia ::= sent_if 
            {
              Sentencia RESULT =null;
		int sentIFleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sentIFright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		SentenciaSeleccion sentIF = (SentenciaSeleccion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = sentIF; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",30, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // sentencia ::= sentFor 
            {
              Sentencia RESULT =null;
		int sentenciaFORleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sentenciaFORright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		SentenciaRepeticion sentenciaFOR = (SentenciaRepeticion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = sentenciaFOR; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",30, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // sentencia ::= bloqueSent 
            {
              Sentencia RESULT =null;
		int bloqueSentenciasleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bloqueSentenciasright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		BloqueInstrucciones bloqueSentencias = (BloqueInstrucciones)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = bloqueSentencias; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",30, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // sentLocales ::= 
            {
              Sentencias RESULT =null;
		
                  Sentencias sentencias=new Sentencias();
                  RESULT = sentencias;
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentLocales",32, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // sentLocales ::= sentencia sentLocales 
            {
              Sentencias RESULT =null;
		int cualquierSentencialeft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int cualquierSentenciaright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Sentencia cualquierSentencia = (Sentencia)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int sentLocleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sentLocright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Sentencias sentLoc = (Sentencias)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
                Sentencias sentencias = new Sentencias();
                sentencias.addSentencia(cualquierSentencia);
                sentencias.addSentencias(sentLoc.getListaSentencias());
                RESULT = sentencias; 
              
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentLocales",32, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // sentSalidaCadena ::= PRINTC OBRACKET TCHAIN CBRACKET SEMICOLON 
            {
              SentenciaSalidaCadena RESULT =null;
		int sLiteralleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int sLiteralright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token sLiteral = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
              IntermedioSentenciaSalidaCadena sWrite = new IntermedioSentenciaSalidaCadena(sLiteral);
              sWrite.codigoIntermedio();
              RESULT = sWrite;
          
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentSalidaCadena",29, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // sentSalidaValor ::= PRINTI OBRACKET CBRACKET SEMICOLON 
            {
              SentenciaSalidaValor RESULT =null;
		
              IntermedioSentenciaSalidaValor sWrite = new IntermedioSentenciaSalidaValor();
              sWrite.codigoIntermedio();
              RESULT = sWrite;

          
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentSalidaValor",28, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // sentSalidaValor ::= PRINTI OBRACKET expresion CBRACKET SEMICOLON 
            {
              SentenciaSalidaValor RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expresion exp = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
               IntermedioSentenciaSalidaValor sWrite = new IntermedioSentenciaSalidaValor(exp);
               sWrite.codigoIntermedio();      
               RESULT = sWrite;  

        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentSalidaValor",28, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // sentFor ::= FOR OBRACKET expAcceso ASSIGMENT expLog SEMICOLON expLog SEMICOLON expAsig CBRACKET sentencia 
            {
              SentenciaRepeticion RESULT =null;
		int registroleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-8)).left;
		int registroright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-8)).right;
		ExpresionAccesoRegistro registro = (ExpresionAccesoRegistro)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-8)).value;
		int expLogicaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).left;
		int expLogicaright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).right;
		Expresion expLogica = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-6)).value;
		int exp1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int exp1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Expresion exp1 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int exp2left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exp2right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		ExpresionAsignacion exp2 = (ExpresionAsignacion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int sentsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sentsright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Sentencia sents = (Sentencia)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            String identificadorRegisto = registro.getIdentificador();
            String ident2 = registro.getIdentificador2();
            String campoRegistro = registro.getCampo();

            // Busco símbolo del tipo (identificadorRegistro)
            SymbolIF simbolo = scopeManager.searchSymbol(identificadorRegisto);
            //SymbolIF simbolo2 = scopeManager.searchSymbol(campoRegistro);
            TypeIF tipo = scopeManager.searchType(simbolo.getType().getName());

            TypeRecord tipoRec = (TypeRecord) scopeManager.searchType(simbolo.getType().getName());

            HashMap tablaCampos = tipoRec.getCamposTabla();
            SymbolVariable simboloC = (SymbolVariable) tablaCampos.get(campoRegistro);
            SymbolIF simboloDeCampo = (SymbolIF) simboloC;

            ScopeIF scope = scopeManager.getCurrentScope();
/*            Variable var = new Variable(identificadorRegisto, scope);
            var.setAmbito(simbolo.getScope());

            Variable var2 = new Variable(campoRegistro, scope);

            // Senecesita coger la posición del campo dentro del registro
            var2.setDesplazamientoCampo(simboloC.getDesplazamiento());*/

             IntermedioExpresionAsignacionRegistros expAsignacion = new IntermedioExpresionAsignacionRegistros(registro, simbolo, simboloC, expLogica, scope);
             IntermedioSentenciaRepeticion sentRepeticion = new IntermedioSentenciaRepeticion(expAsignacion, exp1, exp2, sents);
             sentRepeticion.codigoIntermedio();
             RESULT = sentRepeticion; 

        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentFor",27, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-10)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // sentFor ::= FOR OBRACKET ID ASSIGMENT expLog SEMICOLON expLog SEMICOLON expAsig CBRACKET sentencia 
            {
              SentenciaRepeticion RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-8)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-8)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-8)).value;
		int expLogicaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).left;
		int expLogicaright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).right;
		Expresion expLogica = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-6)).value;
		int exp1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int exp1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Expresion exp1 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int exp2left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exp2right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		ExpresionAsignacion exp2 = (ExpresionAsignacion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int sentsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sentsright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Sentencia sents = (Sentencia)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            // Se tiene que comprobar que id es de tipo entero y que ha sido declarado
            if (!(scopeManager.containsSymbol(id.getLexema())))
                semanticErrorManager.semanticFatalError(SemanticErrors.Indice_no_declarado, id );

               // Se comprueba que la inicializacion de la variable es una Constante literal
             if (!(expLogica instanceof ExpresionConstanteLiteral))
               semanticErrorManager.semanticFatalError(SemanticErrors.Valor_indice_incorrecto, id );

              // Se comprueba que exp1 se hace un control relacional válido (solamente posible con >) y equivale a >=
             if (!(exp1 instanceof ExpresionMAYOR))
               semanticErrorManager.semanticFatalError(SemanticErrors.Expresion_logica_no_valida, id );


              // Se comprueba que id2 es igual a id1 (para evitar un bucle infinito) 
/*
              String indice = id.getLexema();
              //String indiceSiguiente = id2.getLexema();

              Token indice2          = exp2.getId();

              String indiceSiguiente = indice2.getLexema();
              System.out.println(indiceSiguiente);
             // SymbolIF contador = exp2.getSimbolo();
             // String indiceSiguiente = contador.getName();
       
            if(!(simbolo.getType().getName().equals(expLogica.getTipoExpresion().getName())))

              if (!(indice.equals(indiceSiguiente)))
                semanticErrorManager.semanticFatalError(SemanticErrors.Variable_no_coincide, id);*/
/*
              // Se comprueba que en exp2 se decrementa la variable de control del FOR
              if (!(exp2.getExpresion() instanceof ExpresionRESTA))
                semanticErrorManager.semanticFatalError(SemanticErrors.Expresion_logica_no_valida_2, m );
*/
              String    nombre = id.getLexema();
              SymbolIF simbolo = scopeManager.searchSymbol(nombre);
              TypeIF      tipo = simbolo.getType();

             IntermedioExpresionAsignacion expAsignacion = new IntermedioExpresionAsignacion(simbolo, expLogica);
             // Código intermedio
             IntermedioSentenciaRepeticion sentRepeticion = new IntermedioSentenciaRepeticion(expAsignacion, exp1, exp2, sents);
             sentRepeticion.codigoIntermedio();
             RESULT = sentRepeticion; 
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentFor",27, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-10)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // sent_if ::= IF OBRACKET expresion CBRACKET sentencia ELSE sentencia 
            {
              SentenciaSeleccion RESULT =null;
		int apleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int apright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Token ap = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Expresion exp = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int bloqueIfleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int bloqueIfright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Sentencia bloqueIf = (Sentencia)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int bloqueElseleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bloqueElseright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Sentencia bloqueElse = (Sentencia)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		

         IntermedioSentenciaSeleccion sentSeleccion = new IntermedioSentenciaSeleccion(exp, bloqueIf, bloqueElse);
         sentSeleccion.codigoIntermedio();
         RESULT = sentSeleccion;

        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sent_if",33, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // sent_if ::= IF OBRACKET expresion CBRACKET sentencia 
            {
              SentenciaSeleccion RESULT =null;
		int apleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int apright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token ap = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expresion exp = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int bloqueSentenciasleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bloqueSentenciasright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Sentencia bloqueSentencias = (Sentencia)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		

         IntermedioSentenciaSeleccion sentSeleccion = new IntermedioSentenciaSeleccion(exp, bloqueSentencias);
         sentSeleccion.codigoIntermedio();
         RESULT = sentSeleccion;

        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sent_if",33, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // bloqueSent ::= OBRACE NT$8 dectipos decvariables sentLocales NT$9 CBRACE 
            {
              BloqueInstrucciones RESULT =null;
              // propagate RESULT from NT$9
                RESULT = (BloqueInstrucciones) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int sentLocleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int sentLocright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Sentencias sentLoc = (Sentencias)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("bloqueSent",31, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // NT$9 ::= 
            {
              BloqueInstrucciones RESULT =(BloqueInstrucciones) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int sentLocleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sentLocright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Sentencias sentLoc = (Sentencias)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;


                scopeManager.openScope();

                BloqueInstrucciones sentencias = new BloqueInstrucciones();
                sentencias.addInstrucciones(sentLoc.getListaSentencias());
                RESULT = sentencias;

              
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$9",43, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // NT$8 ::= 
            {
              BloqueInstrucciones RESULT =null;



            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$8",42, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // invFuncA ::= expresion COMMA invFuncA 
            {
              ListaParametros RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expresion exp = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int listaParametrosEntradaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int listaParametrosEntradaright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ListaParametros listaParametrosEntrada = (ListaParametros)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		

        ListaParametros lista = new ListaParametros(listaParametrosEntrada);
        lista.add(exp);
        RESULT = lista;

      
              CUP$parser$result = parser.getSymbolFactory().newSymbol("invFuncA",19, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // invFuncA ::= expresion 
            {
              ListaParametros RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion exp = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		

        // Las expresiones válidas son de ID, invFun, 
        ListaParametros lista = new ListaParametros();
        lista.add(exp);
        RESULT = lista;
      
              CUP$parser$result = parser.getSymbolFactory().newSymbol("invFuncA",19, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // invFunc ::= ID OBRACKET invFuncA CBRACKET 
            {
              LlamadaSubprograma RESULT =null;
		int idFuncionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idFuncionright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token idFuncion = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int listaParametrosEntradaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int listaParametrosEntradaright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		ListaParametros listaParametrosEntrada = (ListaParametros)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		

            ScopeIF scope = scopeManager.getCurrentScope();
            ScopeIF padre = scopeManager.getParentScope();

            // Si la funcion ha sido declarada
            if (!(scopeManager.containsSymbol(idFuncion.getLexema()) || tablaTipos.containsType(idFuncion.getLexema()))) 
              semanticErrorManager.semanticFatalError(SemanticErrors.Simbolo_Funcion_no_declarada, idFuncion );
            
            // Si corresponde con un simbolo de funcion
            SymbolIF funcion = scopeManager.getScope(0).getSymbolTable().getSymbol(idFuncion.getLexema());
            //if (! (funcion.getType() instanceof TypeFunction) )
            //semanticErrorManager.semanticFatalError(SemanticErrors.Simbolo_no_es_de_funcion, idFuncion );


          // Si es de tipo función el símbolo
          if (!(funcion instanceof SymbolFunction))
          { semanticErrorManager.semanticFatalError(SemanticErrors.Simbolo_no_es_de_funcion, idFuncion ); }


            // Se comprueba si el numero de parametros formales y actuales coinciden

            TypeFunction tipoFuncion = (TypeFunction) scopeManager.getScope(0).getTypeTable().getType(idFuncion.getLexema());

            if (listaParametrosEntrada != null){
              ListaParametros lista = new ListaParametros(listaParametrosEntrada);

              if (!tipoFuncion.comparaParametros(listaParametrosEntrada))
              { semanticErrorManager.semanticFatalError(SemanticErrors.Numero_incorrecto_parametros, idFuncion ); }

            //En llamadas a funciones solo se admiten parámetros de tipo INT
            for(Expresion exp : listaParametrosEntrada.getParametros()){
              if (!(exp.getTipoExpresion() instanceof TypeInteger))
              { semanticErrorManager.semanticFatalError(SemanticErrors.Tipo_parametro_incorrecto, idFuncion );}
            }
            
            
      } else if (tipoFuncion.tieneParametros()){
        semanticErrorManager.semanticFatalError(SemanticErrors.Numero_incorrecto_parametros, idFuncion );
      }

      LlamadaSubprograma invFuncion = new LlamadaSubprograma(idFuncion, listaParametrosEntrada);

      RESULT = invFuncion;
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("invFunc",18, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // invFunc ::= ID OBRACKET CBRACKET 
            {
              LlamadaSubprograma RESULT =null;
		int idFuncionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idFuncionright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token idFuncion = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		 

            ScopeIF scope = scopeManager.getCurrentScope();
          
            // Si la funcion ha sido declarada
            if (!(scopeManager.containsSymbol(idFuncion.getLexema()) || tablaTipos.containsType(idFuncion.getLexema()))) 
            semanticErrorManager.semanticFatalError(SemanticErrors.Simbolo_Funcion_no_declarada, idFuncion );
            
            // Si corresponde con un simbolo de funcion
            SymbolIF funcion = scopeManager.searchSymbol(idFuncion.getLexema());
           // if (! (funcion.getType() instanceof TypeFunction) )
           // semanticErrorManager.semanticFatalError(SemanticErrors.Simbolo_no_es_de_funcion, idFuncion );

          // Si es de tipo función el símbolo
          if (!(funcion instanceof SymbolFunction))
          { semanticErrorManager.semanticFatalError(SemanticErrors.Simbolo_no_es_de_funcion, idFuncion ); }

              RESULT = new LlamadaSubprograma(idFuncion, new ListaParametros());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("invFunc",18, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // expAcceso ::= ID POINT ID POINT ID 
            {
              ExpresionAccesoRegistro RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int id2left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int id2right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token id2 = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int campoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int camporight = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token campo = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		

                ScopeIF scope = scopeManager.getCurrentScope();

                // Busco el simbolo para verificar que existe id (variable declarada)
                if ( !(scopeManager.containsSymbol(id.getLexema())) ) 
                { semanticErrorManager.semanticFatalError(SemanticErrors.Simbolo_no_declarado, id ); }

                // Se encuentra el tipo de la variable 
                SymbolIF simbolo = scopeManager.searchSymbol(id.getLexema());

                TypeIF tipo = scopeManager.searchType(simbolo.getType().getName());
                // Se verifica que es de tipo Registro 
                if ( !(tipo instanceof TypeRecord ) )
                { semanticErrorManager.semanticFatalError(SemanticErrors.Tipo_incorrecto, id ); }

                // Se busca en la tabla de tipos el tipo (id) y si contiene el campo (id2) 
                TypeRecord tipoRec = (TypeRecord) scopeManager.searchType(simbolo.getType().getName());
                if ( tipoRec.getTypeCampo(id2.getLexema()) == null ) 
                    semanticErrorManager.semanticFatalError(SemanticErrors.Campo_no_declarado, id2 );

                HashMap tablaCampos = tipoRec.getCamposTabla();
                SymbolVariable simboloC = (SymbolVariable) tablaCampos.get(id2.getLexema());

                // Este el simbolo del campo de en medio
                SymbolIF simboDeCampoIntermedio = (SymbolIF) simboloC;

                TypeIF tipo2 = scopeManager.searchType(simboDeCampoIntermedio.getType().getName());
 
                // Se verifica que id2 es de tipo estructurado
                if ( !(tipo2 instanceof TypeRecord ) )
                { semanticErrorManager.semanticFatalError(SemanticErrors.Tipo_incorrecto, id2 ); }

                // Se busca en la tabla de tipos el tipo (id2) y si contiene el campo 
                TypeRecord tipoRec2 = (TypeRecord) scopeManager.searchType(simboDeCampoIntermedio.getType().getName());
                if ( tipoRec2.getTypeCampo(campo.getLexema()) == null ) 
                    semanticErrorManager.semanticFatalError(SemanticErrors.Campo_no_declarado, campo );

                String ident1 = id.getLexema();
                String ident2 = id2.getLexema();
                String simboloCampo = campo.getLexema();

                ExpresionAccesoRegistro registro = new ExpresionAccesoRegistro(ident1, ident2, simboloCampo);

                RESULT = registro;
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expAcceso",17, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // expAcceso ::= ID POINT ID 
            {
              ExpresionAccesoRegistro RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int campoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int camporight = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token campo = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		

                ScopeIF scope = scopeManager.getCurrentScope();

                // Busco el simbolo para verificar que existe el simblolo

                if ( !(scopeManager.containsSymbol(id.getLexema())) ) 
                { semanticErrorManager.semanticFatalError(SemanticErrors.Simbolo_no_declarado, id ); }
                
                // Se encuentra el símbolo
                SymbolIF simbolo = scopeManager.searchSymbol(id.getLexema());
                TypeIF tipo = scopeManager.searchType(simbolo.getType().getName());
               
               // Se verifica que el simbolo es de tipo estructurado
                if ( !(tipo instanceof TypeRecord) )
                { semanticErrorManager.semanticFatalError(SemanticErrors.Tipo_incorrecto, id ); }

                // Se busca en la tabla de tipos el tipo y si contiene el campo 
                TypeRecord tipoRec = (TypeRecord) scopeManager.searchType(simbolo.getType().getName());
                if ( tipoRec.getTypeCampo(campo.getLexema()) == null ) 
                    semanticErrorManager.semanticFatalError(SemanticErrors.Simbolo_no_declarado, campo );

                String tipoRegistro = id.getLexema();
                String simboloCampo = campo.getLexema();

                ExpresionAccesoRegistro registro = new ExpresionAccesoRegistro(tipoRegistro, null, simboloCampo);

                RESULT = registro;

             
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expAcceso",17, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // expAsig ::= expAcceso ASSIGMENT expLog 
            {
              ExpresionAsignacion RESULT =null;
		int registroleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int registroright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		ExpresionAccesoRegistro registro = (ExpresionAccesoRegistro)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int expLogicaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expLogicaright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion expLogica = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		   

            ScopeIF scope = scopeManager.getCurrentScope();
            String identificadorRegisto = registro.getIdentificador();
            String ident2 = registro.getIdentificador2();
            String campoRegistro = registro.getCampo();

            // Posible pendiente ..........................................

            // La asignación de tipo c1.fecha = f.dia  no está permitida
             if(expLogica instanceof ExpresionAccesoRegistro)
             { semanticErrorManager.semanticFatalError(SemanticErrors.Asignacion_no_permitida, null); }

            // La asignación de tipo  c1.fecha (tipoReg) = f (var tipo Reg) no está permitida   
            if(expLogica.getTipoExpresion() instanceof TypeRecord)
            { semanticErrorManager.semanticFatalError(SemanticErrors.Asignacion_no_permitida, null); }

            // -------------------------------------------------------------

            // Busco símbolo del tipo (identificadorRegistro)
            SymbolIF simbolo = scopeManager.searchSymbol(identificadorRegisto);
            //SymbolIF simbolo2 = scopeManager.searchSymbol(campoRegistro);
            TypeIF tipo = scopeManager.searchType(simbolo.getType().getName());

            TypeRecord tipoRec = (TypeRecord) scopeManager.searchType(simbolo.getType().getName());

            HashMap tablaCampos = tipoRec.getCamposTabla();

              // Este se utiliza en el if y en el else
              SymbolVariable simboloC = (SymbolVariable) tablaCampos.get(campoRegistro);
              SymbolIF simboDeCampo = (SymbolIF) simboloC;

            if (ident2 == null){

              IntermedioExpresionAsignacionRegistros expAsignacion = new IntermedioExpresionAsignacionRegistros(registro, simbolo, simboloC, expLogica, scope);
              expAsignacion.codigoIntermedio();

             RESULT = expAsignacion;

            } else {

              //HashMap tablaCampos = tipoRec.getCamposTabla();
              SymbolVariable simboloCIn = (SymbolVariable) tablaCampos.get(ident2);
              SymbolIF simboDeCampoIntermedio = (SymbolIF) simboloCIn;

              anidamientoReg++;
              IntermedioExpresionAsignacionRegistros expAsignacion = new IntermedioExpresionAsignacionRegistros(registro, simbolo, simboloC, expLogica, scope, anidamientoReg);
              expAsignacion.codigoIntermedio();

             RESULT = expAsignacion;             
            }

            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expAsig",16, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // expAsig ::= ID ASSIGMENT expLog 
            {
              ExpresionAsignacion RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int expLogicaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expLogicaright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion expLogica = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		

              // Se comprueba la existencia del símbolo
              String    nombre = id.getLexema();
              SymbolIF simbolo = scopeManager.searchSymbol(nombre);
              TypeIF      tipo = simbolo.getType();

              // El símbolo de la parte izquierda no está declarado
              // Esto me ha dejado de funcionar al incluir la asignacion inicial de variables
              if ((simbolo == null)|| !(scopeManager.containsSymbol(nombre)))
              { semanticErrorManager.semanticFatalError(SemanticErrors.Simbolo_no_declarado, id); }

              //  Se verifica que el tipo de la variable es de tipo entero.
              if (!(tipo instanceof TypeInteger))
                { semanticErrorManager.semanticFatalError(SemanticErrors.Asignacion_no_permitida, id); }

              IntermedioExpresionAsignacion expAsignacion = new IntermedioExpresionAsignacion(simbolo, expLogica);
              expAsignacion.codigoIntermedio();

              RESULT = expAsignacion;

          
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expAsig",16, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // expLog ::= expAcceso 
            {
              Expresion RESULT =null;
		int registroleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int registroright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ExpresionAccesoRegistro registro = (ExpresionAccesoRegistro)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		

            ScopeIF scope = scopeManager.getCurrentScope();
            String identificadorRegisto = registro.getIdentificador();
            String ident2 = registro.getIdentificador2();
            String campoRegistro = registro.getCampo();

            // Busco símbolo del tipo (identificadorRegistro)
            SymbolIF simbolo = scopeManager.searchSymbol(identificadorRegisto);
            //SymbolIF simbolo2 = scopeManager.searchSymbol(campoRegistro);
            TypeIF tipo = scopeManager.searchType(simbolo.getType().getName());

            TypeRecord tipoRec = (TypeRecord) scopeManager.searchType(simbolo.getType().getName());

            HashMap tablaCampos = tipoRec.getCamposTabla();
            SymbolVariable simboloC = (SymbolVariable) tablaCampos.get(campoRegistro);
            SymbolIF simboloDeCampo = (SymbolIF) simboloC;

            if (ident2 == null){

            ExpresionAccesoRegistro exp = new ExpresionAccesoRegistro(simboloC.getTipo());
            
            desplazaCampoReg++;           
            IntermedioExpresionAccesoRegistro expLlSub = new IntermedioExpresionAccesoRegistro(registro, exp, simbolo, simboloC, scope, desplazaCampoReg);
            expLlSub.codigoIntermedio();
 
            RESULT = expLlSub;

          } else{

            SymbolVariable simboloRegistro2 = (SymbolVariable) tablaCampos.get(ident2);
            // Este el simbolo del campo de en medio
            SymbolIF simboDeCampoIntermedio = (SymbolIF) simboloRegistro2;
            // Hay que captar el tipo Registro de este campo para verificar el tipo del campo 
            TypeRecord tipoRec2 = (TypeRecord) scopeManager.searchType(simboDeCampoIntermedio.getType().getName());

            ExpresionAccesoRegistro exp = new ExpresionAccesoRegistro(tipoRec2.getTypeCampo(campoRegistro));

            diccionario.put(anidamientoReg, desplazaCampoAnidado);

            desplazaCampoAnidado++;   
            IntermedioExpresionAccesoRegistro expLlSub = new IntermedioExpresionAccesoRegistro(registro, exp, simbolo, simboloC, scope, desplazaCampoAnidado, anidamientoReg, diccionario);
            expLlSub.codigoIntermedio();
 
            RESULT = expLlSub;

          }
      
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expLog",15, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // expLog ::= invFunc 
            {
              Expresion RESULT =null;
		int llamadaSubPleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int llamadaSubPright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		LlamadaSubprograma llamadaSubP = (LlamadaSubprograma)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		  

      // No se permite que la función invocada devuelva un tipo VOID en expresiones

        Token id         = llamadaSubP.getId();
        String nombre    = id.getLexema();
        SymbolIF simbolo = scopeManager.searchSymbol(nombre);
        TypeIF tipoRetorno = scopeManager.searchType(id.getLexema());
        
        SymbolFunction simboloFuncion = (SymbolFunction) simbolo;

        if (!(simboloFuncion.get_devuelve_tipo() instanceof TypeInteger)){
          semanticErrorManager.semanticFatalError(SemanticErrors.Retorno_de_funcion_incorrecto, id); }

        // Código Intermedio
        IntermedioExpresionLlamadaSubprograma expLlSub = new IntermedioExpresionLlamadaSubprograma(simboloFuncion, llamadaSubP);
        expLlSub.codigoIntermedio();
        RESULT = expLlSub;

        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expLog",15, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // expLog ::= NUM 
            {
              Expresion RESULT =null;
		int cteLiteralleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cteLiteralright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token cteLiteral = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		

        ScopeIF scope = scopeManager.getCurrentScope();
        Value value = null;

        // Casting del valor de NUM a Integer
        Integer miConstante = new Integer(Integer.valueOf(cteLiteral.getLexema().toUpperCase()).intValue());
        value = new Value(miConstante);

        IntermedioExpresionConstanteLiteral expLITERAL = new IntermedioExpresionConstanteLiteral(new TypeInteger(scope), miConstante);
        expLITERAL.codigoIntermedio(value);

        RESULT = expLITERAL;
      
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expLog",15, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // expLog ::= ID 
            {
              Expresion RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
        String nombre    = id.getLexema();
        SymbolIF simbolo = scopeManager.searchSymbol(nombre);

        // El símbolo no está registrado!
        if(simbolo == null)
        { semanticErrorManager.semanticFatalError(SemanticErrors.Operador_no_declarado, id); }

        // Se comprueba que symbol es o una constante o una variable
        // (primitiva o compuesta) o un parámetro formal.

        // El símbolo no está registrado!
        if(simbolo instanceof SymbolReturn)
        { semanticErrorManager.semanticFatalError(SemanticErrors.Referencia_no_asignable, id); }

        Reference   referencia  = new Reference(simbolo, true);

        ExpresionID expID = new ExpresionID(simbolo, simbolo.getType(), id.getLexema());

        // Código Intermedio -- (No hay clase)
        expID.setTemporal(referencia.get_temporal());
        expID.setIntermediateCode(referencia.getICB().create());
        // Fin código Intermedio

        RESULT = expID;

      
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expLog",15, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // expLog ::= OBRACKET expLog CBRACKET 
            {
              Expresion RESULT =null;
		int parentesisleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int parentesisright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Expresion parentesis = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 RESULT = parentesis; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expLog",15, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // expLog ::= expLog EQUAL expLog 
            {
              Expresion RESULT =null;
		int exp1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exp1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expresion exp1 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int operadorleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int operadorright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token operador = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int exp2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int exp2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion exp2 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
        
        IntermedioExpresionIGUAL expIGUAL = new IntermedioExpresionIGUAL(new TypeBoolean(scopeManager.getCurrentScope()));
        expIGUAL.codigoIntermedio(exp1, exp2);
        RESULT = expIGUAL;

        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expLog",15, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // expLog ::= expLog MORE expLog 
            {
              Expresion RESULT =null;
		int exp1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exp1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expresion exp1 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int operadorleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int operadorright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token operador = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int exp2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int exp2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion exp2 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
      
        IntermedioExpresionMAYOR expMAYOR = new IntermedioExpresionMAYOR(new TypeBoolean(scopeManager.getCurrentScope()));
        expMAYOR.codigoIntermedio(exp1, exp2);
        RESULT = expMAYOR;

        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expLog",15, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // expLog ::= expLog OR expLog 
            {
              Expresion RESULT =null;
		int exp1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exp1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expresion exp1 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int operadorleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int operadorright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token operador = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int exp2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int exp2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion exp2 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		

         IntermedioExpresionOR expOR = new IntermedioExpresionOR(new TypeBoolean(scopeManager.getCurrentScope()));
         expOR.codigoIntermedio(exp1, exp2);
         RESULT = expOR;

        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expLog",15, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // expLog ::= expLog MINUS expLog 
            {
              Expresion RESULT =null;
		int exp1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exp1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expresion exp1 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int operadorleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int operadorright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token operador = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int exp2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int exp2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion exp2 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		

         IntermedioExpresionRESTA expResta = null;
         expResta = new IntermedioExpresionRESTA(exp1.getTipoExpresion());
         expResta.codigoIntermedio(exp1,exp2);
         RESULT = expResta;

        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expLog",15, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // expresion ::= expAsig 
            {
              Expresion RESULT =null;
		int expAsignacionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expAsignacionright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ExpresionAsignacion expAsignacion = (ExpresionAsignacion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = expAsignacion; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",14, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // expresion ::= expLog 
            {
              Expresion RESULT =null;
		int expLogicaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expLogicaright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion expLogica = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = expLogica; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",14, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // bloqueMain ::= dectipos decvariables sentLocales 
            {
              Bloque RESULT =null;
		int sentLocalesleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sentLocalesright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Sentencias sentLocales = (Sentencias)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
          Bloque bloqueSentencias = new Bloque(sentLocales);
          RESULT = bloqueSentencias; 
          
              CUP$parser$result = parser.getSymbolFactory().newSymbol("bloqueMain",26, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // main ::= VOID MAIN OBRACKET NT$6 CBRACKET OBRACE bloqueMain NT$7 CBRACE 
            {
              Axiom RESULT =null;
              // propagate RESULT from NT$7
                RESULT = (Axiom) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-7)).value;
		int bloqueSentenciasleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int bloqueSentenciasright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Bloque bloqueSentencias = (Bloque)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		   scopeManager.closeScope(); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("main",25, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-8)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // NT$7 ::= 
            {
              Axiom RESULT =(Axiom) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int bloqueSentenciasleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bloqueSentenciasright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Bloque bloqueSentencias = (Bloque)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
 

        IntermedioAxiom ax = new IntermedioAxiom(id, bloqueSentencias);
        ax.codigoIntermedio();

        RESULT = ax; 


        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$7",41, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // NT$6 ::= 
            {
              Axiom RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;


        // scopeManager.closeScope(); 
        String nombre = id.getLexema();
        if(scopeManager.containsSymbol(nombre))
        // Simbolo duplicado: identificador ya utilizado
        {  semanticErrorManager.semanticFatalError(SemanticErrors.Simbolo_Ident_utilizado, id); }
        if(scopeManager.containsType(nombre))
        // Tipo duplicado: ya se ha declarado un tipo con ese identificador
        { semanticErrorManager.semanticFatalError(SemanticErrors.Tipo_Ident_utilizado, id); }
        // Sin error, se crea un nuevo ámbito de subprograma.
        scopeManager.openScope(nombre);

      //Añadimos la función a la tabla de tipos
       if (!tablaTipos.addType(new TypeFunction(scopeManager.getParentScope(),id.getLexema())))
       { semanticErrorManager.semanticFatalError(SemanticErrors.Tipo_Ident_utilizado, id); }

      //Añadimos la función a la tabla de símbolos
      if(!tablaSimbolos.addSymbol(new SymbolFunction(scopeManager.getParentScope(), id.getLexema(), scopeManager.searchType(id.getLexema()))))
      { semanticErrorManager.semanticFatalError(SemanticErrors.Simbolo_Ident_utilizado, id); }

      
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$6",40, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // funcionE ::= INT ID 
            {
              DeclaracionListaParametros RESULT =null;
		int tipoPrimitivoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int tipoPrimitivoright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token tipoPrimitivo = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int idParamleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idParamright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token idParam = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
          //Comprobamos que el parámetro no coincida con ninguna constante ya declarada
        SymbolIF simbolo = scopeManager.searchSymbol(idParam.getLexema());
        if (simbolo != null && simbolo instanceof SymbolConstant)
        { semanticErrorManager.semanticFatalError(SemanticErrors.Simbolo_utilizado_constante, idParam); }

          //Comprobamos que el parámetro no coincida con ningún tipo ya declarado
        if (scopeManager.containsType(idParam.getLexema()))
        { semanticErrorManager.semanticFatalError(SemanticErrors.Simbolo_duplicado_tipo, idParam); }

        ScopeIF scope = scopeManager.getCurrentScope();

        SymbolParameter parametro = new SymbolParameter(scopeManager.getCurrentScope(), idParam.getLexema(), new TypeInteger(scope));

          //Lo añadimos a la tabla de símbolos
        if (!tablaSimbolos.addSymbol(parametro))
        { semanticErrorManager.semanticFatalError(SemanticErrors.Simbolo_duplicado, idParam); }

        DeclaracionListaParametros lista = new DeclaracionListaParametros();          
        lista.addParameter(parametro);

        RESULT = lista;
       
              CUP$parser$result = parser.getSymbolFactory().newSymbol("funcionE",22, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // funcionE ::= INT ID COMMA funcionE 
            {
              DeclaracionListaParametros RESULT =null;
		int tipoPrimitivoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int tipoPrimitivoright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token tipoPrimitivo = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int idParamleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idParamright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token idParam = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int valor_Eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int valor_Eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		DeclaracionListaParametros valor_E = (DeclaracionListaParametros)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
        //Comprobamos que el parámetro no coincida con ninguna constante ya declarada
        SymbolIF simbolo = scopeManager.searchSymbol(idParam.getLexema());
        if (simbolo != null && simbolo instanceof SymbolConstant)
        { semanticErrorManager.semanticFatalError(SemanticErrors.Simbolo_utilizado_constante, idParam); }
          
        //Comprobamos que el parámetro no coincida con ningún tipo ya declarado
        if (scopeManager.containsType(idParam.getLexema()))
        { semanticErrorManager.semanticFatalError(SemanticErrors.Simbolo_duplicado_tipo, idParam); }

        ScopeIF scope = scopeManager.getCurrentScope();

        SymbolParameter parametro = new SymbolParameter(scopeManager.getCurrentScope(), idParam.getLexema(), new TypeInteger(scope));
        //Lo añadimos a la tabla de símbolos
        if (!tablaSimbolos.addSymbol(parametro))
        { semanticErrorManager.semanticFatalError(SemanticErrors.Simbolo_duplicado, idParam); }
        valor_E.addParameter(parametro);

        RESULT = valor_E;
     
              CUP$parser$result = parser.getSymbolFactory().newSymbol("funcionE",22, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // funcionA ::= dectipos decvariables sentLocales 
            {
              CuerpoFuncion RESULT =null;
		int listaSentleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int listaSentright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Sentencias listaSent = (Sentencias)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
        CuerpoFuncion cuerpo = new CuerpoFuncion(listaSent);
        RESULT = cuerpo;
      
              CUP$parser$result = parser.getSymbolFactory().newSymbol("funcionA",21, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // funcionS ::= CBRACKET NT$5 OBRACE funcionA CBRACE 
            {
              DeclaracionFuncion RESULT =null;
              // propagate RESULT from NT$5
                RESULT = (DeclaracionFuncion) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int valor_Aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int valor_Aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		CuerpoFuncion valor_A = (CuerpoFuncion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
          DeclaracionFuncion dec = new DeclaracionFuncion();
          dec.setCuerpoFuncion(valor_A);

          RESULT = dec;
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("funcionS",23, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // NT$5 ::= 
            {
              DeclaracionFuncion RESULT =null;

            ScopeIF scope = scopeManager.getCurrentScope();
            TypeFunction tf = new TypeFunction(scopeManager.getScope(0), scope.getName(),null);
            tablaTipos.addType(tf);

          
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$5",39, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // funcionS ::= funcionE CBRACKET OBRACE NT$4 funcionA CBRACE 
            {
              DeclaracionFuncion RESULT =null;
              // propagate RESULT from NT$4
                RESULT = (DeclaracionFuncion) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int valor_Eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int valor_Eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		DeclaracionListaParametros valor_E = (DeclaracionListaParametros)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int valor_Aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int valor_Aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		CuerpoFuncion valor_A = (CuerpoFuncion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
      DeclaracionFuncion dec = new DeclaracionFuncion(valor_E);
      dec.setCuerpoFuncion(valor_A);

      RESULT = dec;
    
              CUP$parser$result = parser.getSymbolFactory().newSymbol("funcionS",23, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // NT$4 ::= 
            {
              DeclaracionFuncion RESULT =null;
		int valor_Eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int valor_Eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		DeclaracionListaParametros valor_E = (DeclaracionListaParametros)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;

    
    ScopeIF scope = scopeManager.getCurrentScope();
    TypeFunction tf = new TypeFunction(scopeManager.getScope(0), scope.getName(),valor_E);
    tablaTipos.addType(tf);
    SymbolIF sf = scopeManager.getParentScope().getSymbolTable().getSymbol(scope.getName());

    if(sf instanceof SymbolFunction){
      ((SymbolFunction)sf).set_lista_parametros_formales(valor_E.getParametros());
    }

  
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$4",38, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // funcion ::= INT ID NT$3 OBRACKET funcionS 
            {
              Subprograma RESULT =null;
              // propagate RESULT from NT$3
                RESULT = (Subprograma) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int tipoPrimitivoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int tipoPrimitivoright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Token tipoPrimitivo = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int valor_Sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int valor_Sright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		DeclaracionFuncion valor_S = (DeclaracionFuncion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		  

      String nombre = id.getLexema(); 
      ScopeIF scope = scopeManager.getCurrentScope();
      TypeIF tipoRetorno = new TypeInteger(scope);
      valor_S.setNombre(id.getLexema());
      DeclaracionListaParametros dec_parametros = valor_S.getListaParametros();
      ArrayList<SymbolParameter> listaParametros = null;
      if (dec_parametros != null){
        listaParametros = dec_parametros.getParametros();
      }

      //Comprobamos que contenga instrucción de retorno
      //if (!valor_S.tieneRetorno())
      //{ semanticErrorManager.semanticFatalError(SemanticErrors.No_instruccion_retorno, id);}
      
      //Comprobamos que el tipo de la expresión de retorno es correcto
      CuerpoFuncion cuerpo = valor_S.getCuerpoFuncion();
      ArrayList<Sentencia> listaSentencias = cuerpo.getListaSentencias().getListaSentencias();

      // Comprobacion si Retorno correcto (deja de funcionar)
      if (listaSentencias != null && listaSentencias.size() > 0){
        for(Sentencia sent : listaSentencias){
          if (sent instanceof SentenciaReturn){
            Expresion expretorno = ((SentenciaReturn)sent).getExpresion();            
              if (expretorno == null || !(expretorno.getTipoExpresion() instanceof TypeInteger))
            { semanticErrorManager.semanticFatalError(SemanticErrors.Tipo_incorrecto_retorno_2, id);}

        // Se añade el retorno (ojo que está duplicado el símbolo)

          TypeInteger tipo = new TypeInteger(scopeManager.getCurrentScope());
          ScopeIF ambito = scopeManager.getCurrentScope();
          SymbolReturn retornoFuncion = new SymbolReturn(ambito, nombre, tipo);
          tablaSimbolos.addSymbol(retornoFuncion);

          // duplicado ----

          // Se hace la asignación del Retorno a la expresión de retorno
          SymbolIF simbolo = scopeManager.searchSymbol(nombre);
          Reference   referencia  = new Reference(simbolo, true);
          //ExpresionID expID = new ExpresionID(simbolo.getType());  

           // Código Intermedio -- (No hay clase)
           expretorno.setTemporal(referencia.get_temporal());
           expretorno.setIntermediateCode(referencia.getICB().create());
           // Fin código Intermedio

          }
        }
      }
      
     SymbolIF sff = tablaSimbolos.searchSymbol(id.getLexema());
      if(sff instanceof SymbolFunction){
        ((SymbolFunction)sff).set_devuelve_tipo(tipoRetorno);
        ((SymbolFunction)sff).set_lista_parametros_formales(listaParametros);
      }
      else{
        sff= new SymbolFunction(scopeManager.getParentScope(), id.getLexema(), scopeManager.searchType(id.getLexema()), listaParametros, tipoRetorno);
      }

      scopeManager.closeScope();

      // Se necesita capturar el bloque de delcaraciones
      IntermedioSubprograma subProg = new IntermedioSubprograma(cuerpo, tipoRetorno);
      subProg.codigoIntermedio(nombre);
      RESULT = subProg;

    
              CUP$parser$result = parser.getSymbolFactory().newSymbol("funcion",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // NT$3 ::= 
            {
              Subprograma RESULT =null;
		int tipoPrimitivoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int tipoPrimitivoright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token tipoPrimitivo = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
                
      //Creamos un nuevo ámbito para la función
      String nombre = id.getLexema(); 
      ScopeIF scope = scopeManager.openScope(nombre);

      if(scopeManager.containsSymbol(nombre))
      // Simbolo duplicado: identificador ya utilizado
      {  semanticErrorManager.semanticFatalError(SemanticErrors.Simbolo_Ident_utilizado, id); }
      if(scopeManager.containsType(nombre))
      // Tipo duplicado: ya se ha declarado un tipo con ese identificador
      { semanticErrorManager.semanticFatalError(SemanticErrors.Tipo_Ident_utilizado, id); }

      SymbolFunction sf = new SymbolFunction(scopeManager.getCurrentScope(),id.getLexema(),new TypeFunction(scope));
      sf.set_devuelve_tipo(new TypeInteger());
      tablaSimbolos.addSymbol(sf);
  

    
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$3",37, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // funcion ::= VOID ID NT$2 OBRACKET funcionS 
            {
              Subprograma RESULT =null;
              // propagate RESULT from NT$2
                RESULT = (Subprograma) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int tipoVoidleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int tipoVoidright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Token tipoVoid = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int valor_Sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int valor_Sright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		DeclaracionFuncion valor_S = (DeclaracionFuncion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		

        String nombre = id.getLexema();        
        TypeIF tipoRetorno = scopeManager.searchType(tipoVoid.getLexema());
        valor_S.setNombre(id.getLexema());
        DeclaracionListaParametros dec_parametros = valor_S.getListaParametros();
        ArrayList<SymbolParameter> listaParametros = null;
        if (dec_parametros != null){
          listaParametros = dec_parametros.getParametros();
        }

      //Comprobamos que el tipo de la expresión de retorno es correcto
      CuerpoFuncion cuerpo = valor_S.getCuerpoFuncion();
      if (cuerpo.getListaSentencias() != null){
        ArrayList<Sentencia> listaSentencias = cuerpo.getListaSentencias().getListaSentencias();
        if (listaSentencias != null && listaSentencias.size() > 0){
          for(Sentencia sent : listaSentencias){
            if (sent instanceof SentenciaReturn){
              Expresion expretorno = ((SentenciaReturn)sent).getExpresion();
              if (expretorno != null)
              { semanticErrorManager.semanticFatalError(SemanticErrors.Tipo_incorrecto_retorno_1, id);}
            }
          }
        }
      }


       SymbolFunction sff = (SymbolFunction)tablaSimbolos.searchSymbol(id.getLexema());
       sff.set_devuelve_tipo(tipoRetorno);
       sff.set_lista_parametros_formales(listaParametros);

        scopeManager.closeScope();  

      // Se necesita capturar el bloque de delcaraciones
      IntermedioSubprograma subProg = new IntermedioSubprograma(cuerpo, tipoRetorno);
      subProg.codigoIntermedio(nombre);
      RESULT = subProg;


      
              CUP$parser$result = parser.getSymbolFactory().newSymbol("funcion",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // NT$2 ::= 
            {
              Subprograma RESULT =null;
		int tipoVoidleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int tipoVoidright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token tipoVoid = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
       
      //Creamos un nuevo ámbito para la función
      String nombre = id.getLexema();
      scopeManager.openScope(nombre);
      
       if(scopeManager.containsSymbol(nombre))
          // Simbolo duplicado: identificador ya utilizado
          {  semanticErrorManager.semanticFatalError(SemanticErrors.Simbolo_Ident_utilizado, id); }
          if(scopeManager.containsType(nombre))
          // Tipo duplicado: ya se ha declarado un tipo con ese identificador
          { semanticErrorManager.semanticFatalError(SemanticErrors.Tipo_Ident_utilizado, id); }

        SymbolFunction sf = new SymbolFunction(scopeManager.getCurrentScope(),id.getLexema(),scopeManager.searchType(tipoVoid.getLexema()));
        tablaSimbolos.addSymbol(sf);

    
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$2",36, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // decfunciones ::= main 
            {
              Subprogramas RESULT =null;
		int principalleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int principalright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Axiom principal = (Axiom)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 

                  Subprogramas subPro = new Subprogramas();
                  subPro.getIntermediateCode().addAll(principal.getIntermediateCode());
                  RESULT = subPro; 

                  
              CUP$parser$result = parser.getSymbolFactory().newSymbol("decfunciones",24, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // decfunciones ::= funcion decfunciones 
            {
              Subprogramas RESULT =null;
		int funcionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int funcionright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Subprograma funcion = (Subprograma)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int subleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int subright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Subprogramas sub = (Subprogramas)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		

                   Subprogramas subPro = new Subprogramas();
                   subPro.addSubprograma(funcion);
                   subPro.addSubprograma(sub);
                   RESULT = subPro;
                 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("decfunciones",24, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // variableC ::= ASSIGMENT ID 
            {
              Token RESULT =null;
		int idConstanteleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idConstanteright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token idConstante = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
              RESULT = idConstante;
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("variableC",12, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // variableC ::= ASSIGMENT NUM 
            {
              Token RESULT =null;
		int valorleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int valorright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token valor = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
        RESULT = valor;
      
              CUP$parser$result = parser.getSymbolFactory().newSymbol("variableC",12, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // variableB ::= COMMA ID variableC variableB 
            {
              ListaVariables RESULT =null;
		int idVarleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idVarright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token idVar = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int var_cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int var_cright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token var_c = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int lista_Bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int lista_Bright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ListaVariables lista_B = (ListaVariables)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            // Se guarda identificadores en una lista
            if (lista_B == null){
              lista_B = new ListaVariables();
            }
            TokenVar var = new TokenVar(idVar, var_c);
            lista_B.addVariable(var);

            RESULT = lista_B;
          
              CUP$parser$result = parser.getSymbolFactory().newSymbol("variableB",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // variableB ::= COMMA ID variableC 
            {
              ListaVariables RESULT =null;
		int idVarleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int idVarright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token idVar = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int var_cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int var_cright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token var_c = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            // Se guarda identificadores en una lista            
            ListaVariables lista_B = new ListaVariables();
            TokenVar var = new TokenVar(idVar, var_c);
            lista_B.addVariable(var);
            RESULT = lista_B;
          
              CUP$parser$result = parser.getSymbolFactory().newSymbol("variableB",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // variableB ::= COMMA ID 
            {
              ListaVariables RESULT =null;
		int idVarleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idVarright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token idVar = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            // Se guarda identificadores en una lista
            ListaVariables lista_B = new ListaVariables();
            
            lista_B.addToken(idVar);
            RESULT = lista_B;
          
              CUP$parser$result = parser.getSymbolFactory().newSymbol("variableB",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // variableB ::= COMMA ID variableB 
            {
              ListaVariables RESULT =null;
		int idVarleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int idVarright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token idVar = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int lista_Bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int lista_Bright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ListaVariables lista_B = (ListaVariables)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            // Se guarda identificadores en una lista
            if (lista_B == null){
              lista_B = new ListaVariables();
            }
            lista_B.addToken(idVar);
            RESULT = lista_B;
          
              CUP$parser$result = parser.getSymbolFactory().newSymbol("variableB",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // variableA ::= ID variableC variableB SEMICOLON 
            {
              ListaVariables RESULT =null;
		int idVarleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idVarright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token idVar = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int var_cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int var_cright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token var_c = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int lista_Bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int lista_Bright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		ListaVariables lista_B = (ListaVariables)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
          // Se guarda identificadores en una lista
          ListaVariables lista_A = new ListaVariables();
          TokenVar var = new TokenVar(idVar, var_c);
          lista_A.addVariable(var);
          if (lista_B != null){
            lista_A.addLista(lista_B);
          }
          RESULT = lista_A;    
       
              CUP$parser$result = parser.getSymbolFactory().newSymbol("variableA",10, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // variableA ::= ID variableC SEMICOLON 
            {
              ListaVariables RESULT =null;
		int idVarleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idVarright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token idVar = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int var_cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int var_cright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token var_c = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
          // Se guarda identificadores en una lista
          ListaVariables lista_A = new ListaVariables();
          TokenVar var = new TokenVar(idVar, var_c);
          lista_A.addVariable(var);
          RESULT = lista_A;   
       
              CUP$parser$result = parser.getSymbolFactory().newSymbol("variableA",10, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // variableA ::= ID variableB SEMICOLON 
            {
              ListaVariables RESULT =null;
		int idVarleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idVarright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token idVar = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int lista_Bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int lista_Bright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		ListaVariables lista_B = (ListaVariables)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
          // Se guarda identificadores en una lista
          ListaVariables lista_A = new ListaVariables();
          lista_A.addToken(idVar);
          if (lista_B != null){
            lista_A.addLista(lista_B);
          }
          RESULT = lista_A;
       
              CUP$parser$result = parser.getSymbolFactory().newSymbol("variableA",10, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // variableA ::= ID SEMICOLON 
            {
              ListaVariables RESULT =null;
		int idVarleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int idVarright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token idVar = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
          // Se guarda identificadores en una lista
          ListaVariables lista_A = new ListaVariables();
          lista_A.addToken(idVar);
          RESULT = lista_A;
       
              CUP$parser$result = parser.getSymbolFactory().newSymbol("variableA",10, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // variable ::= INT variableA 
            {
              DeclaracionVariable RESULT =null;
		int tipoPrimitivoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int tipoPrimitivoright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token tipoPrimitivo = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int lista_Aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int lista_Aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ListaVariables lista_A = (ListaVariables)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
            ScopeIF scope = scopeManager.getCurrentScope();
            DeclaracionVariable variable_nueva = new DeclaracionVariable(lista_A, new TypeInteger(scope)); 
            RESULT = variable_nueva;
         
              CUP$parser$result = parser.getSymbolFactory().newSymbol("variable",9, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // variable ::= ID variableA 
            {
              DeclaracionVariable RESULT =null;
		int tipoRegistroleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int tipoRegistroright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token tipoRegistro = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int lista_Aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int lista_Aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ListaVariables lista_A = (ListaVariables)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
            // Se busca el identificador (ya se sabe que es registro)
            // y se declara la variable
            String   nombre = tipoRegistro.getLexema();
            TypeRecord tipo = (TypeRecord)scopeManager.searchType(nombre);
            if (tipo == null){
              semanticErrorManager.semanticFatalError(SemanticErrors.Tipo_no_declarado, tipoRegistro);
            }
            DeclaracionVariable variable_nueva = new DeclaracionVariable(lista_A, tipo); 

            RESULT = variable_nueva;
         
              CUP$parser$result = parser.getSymbolFactory().newSymbol("variable",9, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // decvariables ::= 
            {
              DeclaracionVariables RESULT =null;
		 IntermedioDeclaracionVariables var = new IntermedioDeclaracionVariables(); RESULT = var; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("decvariables",13, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // decvariables ::= decvariables variable 
            {
              DeclaracionVariables RESULT =null;
		int dvleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int dvright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		DeclaracionVariables dv = (DeclaracionVariables)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int variable_nuevaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int variable_nuevaright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		DeclaracionVariable variable_nueva = (DeclaracionVariable)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		

                ScopeIF scope = scopeManager.getCurrentScope();
                DeclaracionVariables lista_variables = new DeclaracionVariables();
                lista_variables.addVariable(variable_nueva);
                // Recorre array de variables
                // Comprobación de identificadores duplicados

                // DeclaracionVariables
                for(DeclaracionVariable declara_variable : lista_variables.getVariable_Lista_Declaraciones()) 
                  {
                    TypeIF tipo = declara_variable.getType();
                    // DeclaracionVariable
                    for(TokenVar variable : declara_variable.getListaVariables()) 
                    {
                      Token token = variable.getToken();
                      Token valor_asignado = variable.getValorAsignado();
                      if (valor_asignado != null){
                        //Validamos según tipo
                        if (tipo instanceof TypeRecord){
                          //Si es un tipo registro no se permite asignación en la declaración
                          semanticErrorManager.semanticFatalError(SemanticErrors.Variable_no_permitida, token);
                        }else{
                          //Si es un tipo primitivo solo aceptamos valores numéricos y constantes
                          if (!TypeInteger.EsEntero(valor_asignado.getLexema(),false)){
                            //Comprobamos que sea una constante declarada
                            SymbolIF simbolo = scopeManager.searchSymbol(valor_asignado.getLexema());
                            if (!(simbolo instanceof SymbolConstant))
                            { semanticErrorManager.semanticFatalError(SemanticErrors.Asignacion_ValorNoValido, token); }
                          }
                        }
                      }
                      //Comprobamos que no exista un tipo con ese nombre

                           ScopeIF scopeActual = scopeManager.getCurrentScope();
                           // Tabla del ámbito propio
                           TypeTableIF tabla_hija = scopeActual.getTypeTable();

                     if (tabla_hija.containsType(token.getLexema())){
                        semanticErrorManager.semanticFatalError(SemanticErrors.Simbolo_duplicado_tipo, token);
                      }
                      // Comprobación de símbolo de variable
          
                      Integer miValorVariable = 0;
                      
                      if (variable.getValorAsignado() == null){
                          if(!tablaSimbolos.addSymbol(new SymbolVariable(scope, token.getLexema(), declara_variable.getType(), 0)))
                            { semanticErrorManager.semanticFatalError(SemanticErrors.Simbolo_duplicado, token); }
                      
                      } else {
                            SymbolBase simbolo = (SymbolBase) scopeManager.searchSymbol(valor_asignado.getLexema());

                            // La asignación es con una constante declarada
                            if (simbolo instanceof SymbolConstant){

                              SymbolConstantInteger constanteAsignacion = (SymbolConstantInteger) simbolo;

                              miValorVariable = new Integer(constanteAsignacion.getEntera());
                              // miValorVariable = new String(String.valueOf(variable.getValorAsignado().getLexema()).intValue());

                              if(!tablaSimbolos.addSymbol(new SymbolVariable(scope, token.getLexema(), declara_variable.getType(), miValorVariable, true)))
                              { semanticErrorManager.semanticFatalError(SemanticErrors.Simbolo_duplicado, token); }

/*                                // Si se quiere subir el CI desde aqui
                                 // Buscamos la nueva variable inicializada 
                                 SymbolIF variableInicializada = scopeManager.searchSymbol(variable.getToken().getLexema());

                                 IntermedioDeclaracionVariables varIni = new IntermedioDeclaracionVariables(variableInicializada, variable);
                                 varIni.codigoIntermedio();

                                  ListaVarINI iniVAR = new ListaVarINI();
                                  iniVAR.addVarINI(varIni);

                                  RESULT = iniVAR;*/

                            }

                            else{ 
                              // La asignación es con un entero
                              miValorVariable = new Integer(Integer.valueOf(variable.getValorAsignado().getLexema()).intValue());
             
                              if(!tablaSimbolos.addSymbol(new SymbolVariable(scope, token.getLexema(), declara_variable.getType(), miValorVariable, true)))
                              { semanticErrorManager.semanticFatalError(SemanticErrors.Simbolo_duplicado, token); }
                                 
/*                               // Si se quiere subir el CI desde aqui
                                 // Buscamos la nueva variable inicializada 
                                 SymbolIF variableInicializada = scopeManager.searchSymbol(variable.getToken().getLexema());

                                 IntermedioDeclaracionVariables varIni = new IntermedioDeclaracionVariables(variableInicializada, variable);
                                 varIni.codigoIntermedio();

                                 ListaVarINI iniVAR = new ListaVarINI();
                                 iniVAR.addVarINI(varIni);

                                  RESULT = varIni;*/

                          }
                      }


                    }
                  }


              
              CUP$parser$result = parser.getSymbolFactory().newSymbol("decvariables",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // camporegC ::= COMMA ID SEMICOLON 
            {
              ListaTipos RESULT =null;
		int idVarleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int idVarright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token idVar = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
            // Añadir ID de variable con tipo Registro/INT a lista objetos registro
             ScopeIF scope = scopeManager.getCurrentScope();
             // Tabla del ámbito propio
             TypeTableIF tablaTipos = scope.getTypeTable();
             SymbolIF simbolo = new SymbolVariable(scope,idVar.getLexema(),null);
             ListaTipos listaCampos_C = new ListaTipos();
             CampoReg campos = new CampoReg (idVar.getLexema(), null, idVar.getLine(), idVar.getColumn(),simbolo);
             listaCampos_C.add(campos);

             RESULT = listaCampos_C;
      
              CUP$parser$result = parser.getSymbolFactory().newSymbol("camporegC",7, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // camporegC ::= COMMA ID camporegC 
            {
              ListaTipos RESULT =null;
		int idVarleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int idVarright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token idVar = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int otraleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int otraright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ListaTipos otra = (ListaTipos)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            // Añadir ID de variable con tipo Registro/INT a lista objetos registro
             ScopeIF scope = scopeManager.getCurrentScope();
             // Tabla del ámbito propio
             TypeTableIF tablaTipos = scope.getTypeTable();
             SymbolIF simbolo = new SymbolVariable(scope,idVar.getLexema(),null);
             ListaTipos listaCampos_C;          
             if (otra==null) {
                listaCampos_C = new ListaTipos();
             }else{
                listaCampos_C= new ListaTipos(otra);
             }
             CampoReg campos = new CampoReg (idVar.getLexema(), null, idVar.getLine(), idVar.getColumn(),simbolo);
             listaCampos_C.add(campos);
             RESULT = listaCampos_C;


      
              CUP$parser$result = parser.getSymbolFactory().newSymbol("camporegC",7, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // camporegB ::= ID ID camporegC 
            {
              ListaTipos RESULT =null;
		int tipoRegistroleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int tipoRegistroright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token tipoRegistro = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int idVarleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int idVarright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token idVar = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int listaCampos_Cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int listaCampos_Cright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ListaTipos listaCampos_C = (ListaTipos)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
             // Añadir ID de variable con tipo Registro a lista objetos registro
             ScopeIF scope = scopeManager.getCurrentScope();
             // Si quisieramos que solamente se aniden tipos del mismo ámbito :
             // TypeTableIF tablaTipos = scope.getTypeTable();
             //Comprobamos que el tipo se haya declarado previamente
             if (!tablaTipos.containsType(tipoRegistro.getLexema())){
              semanticErrorManager.semanticFatalError(SemanticErrors.Tipo_no_declarado, tipoRegistro);
             }
             SymbolIF simbolo = new SymbolVariable(scope,idVar.getLexema(),scopeManager.searchType(tipoRegistro.getLexema()), desplazaCampoReg);
             ListaTipos listaCampos_B;
             if (listaCampos_C==null) {
              listaCampos_B = new ListaTipos();
             }else{
              //Recorremos la lista de símbolos y les asociamos el tipo adecuado
              for(Object simbolo_c : listaCampos_C.getVariables()){
                ((CampoReg)simbolo_c).getSimbolo().setType(scopeManager.searchType(tipoRegistro.getLexema()));
              }
                listaCampos_B = new ListaTipos(listaCampos_C);
             }
             CampoReg campos = new CampoReg (idVar.getLexema(), null, idVar.getLine(), idVar.getColumn(),simbolo);
             listaCampos_B.add(campos);
             RESULT = listaCampos_B;
      
              CUP$parser$result = parser.getSymbolFactory().newSymbol("camporegB",6, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // camporegB ::= INT ID camporegC 
            {
              ListaTipos RESULT =null;
		int tipoPrimitivoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int tipoPrimitivoright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token tipoPrimitivo = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int idVarleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int idVarright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token idVar = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int listaCampos_Cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int listaCampos_Cright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ListaTipos listaCampos_C = (ListaTipos)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
             // Añadir ID de variable con tipo INT a lista objetos registro
             ScopeIF scope = scopeManager.getCurrentScope();
             TypeTableIF tablaTipos = scope.getTypeTable();
             SymbolIF simbolo = new SymbolVariable(scope,idVar.getLexema(),new TypeInteger(scope), desplazaCampoReg);
             ListaTipos listaCampos_B;
          
             if (listaCampos_C==null || listaCampos_C.getVariables() == null) {
              listaCampos_B = new ListaTipos();
             }else{
              //Recorremos la lista de símbolos y les asociamos el tipo adecuado
              List<Object> listaVariables_C = listaCampos_C.getVariables();
              for(Object simbolo_c : listaVariables_C){
                ((CampoReg)simbolo_c).getSimbolo().setType(new TypeInteger(scope));
              }
              listaCampos_B = new ListaTipos(listaCampos_C);
             }
             //for(campos : listaCampos_C){por cada simbolo, le asignamos el tipo del tipoPrimitivo}
             CampoReg campos = new CampoReg (idVar.getLexema(), null, idVar.getLine(), idVar.getColumn(),simbolo);
             listaCampos_B.add(campos);
             RESULT = listaCampos_B;
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("camporegB",6, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // camporegB ::= ID ID SEMICOLON 
            {
              ListaTipos RESULT =null;
		int tipoRegistroleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int tipoRegistroright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token tipoRegistro = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int idVarleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int idVarright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token idVar = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
            // Añadir ID de variable con tipo Registro
             ScopeIF scope = scopeManager.getCurrentScope();
             // Si quisieramos que solamente se aniden tipos del mismo ámbito :
             //TypeTableIF tablaTipos = scope.getTypeTable();
             //Comprobamos que el tipo se haya declarado previamente
             if (!tablaTipos.containsType(tipoRegistro.getLexema())){
              semanticErrorManager.semanticFatalError(SemanticErrors.Tipo_no_declarado, tipoRegistro);
             }
             SymbolIF simbolo = new SymbolVariable(scope,idVar.getLexema(),scopeManager.searchType(tipoRegistro.getLexema()), desplazaCampoReg);
             ListaTipos listaCampos_B = new ListaTipos();

             CampoReg campos = new CampoReg (idVar.getLexema(), null, idVar.getLine(), idVar.getColumn(),simbolo);
             listaCampos_B.add(campos);
             RESULT = listaCampos_B;
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("camporegB",6, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // camporegB ::= INT ID SEMICOLON 
            {
              ListaTipos RESULT =null;
		int tipoPrimitivoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int tipoPrimitivoright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token tipoPrimitivo = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int idVarleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int idVarright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token idVar = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		  
             // Añadir ID de variable con tipo INT
             ScopeIF scope = scopeManager.getCurrentScope();
             // Tabla del ámbito propio
             TypeTableIF tablaTipos = scope.getTypeTable();
             //SymbolIF simbolo = new SymbolVariable(scope,idVar.getLexema(),scopeManager.searchType(tipoPrimitivo.getLexema()), despl);
             SymbolIF simbolo = new SymbolVariable(scope,idVar.getLexema(), new TypeInteger(scope) , desplazaCampoReg);
             ListaTipos listaCampos_B = new ListaTipos();

             CampoReg campos = new CampoReg (idVar.getLexema(), null, idVar.getLine(), idVar.getColumn(),simbolo);
             listaCampos_B.add(campos);
             RESULT = listaCampos_B;
          
              CUP$parser$result = parser.getSymbolFactory().newSymbol("camporegB",6, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // camporeg ::= camporeg camporegB 
            {
              ListaTipos RESULT =null;
		int listaCamposleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int listaCamposright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		ListaTipos listaCampos = (ListaTipos)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int listaCampos_Bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int listaCampos_Bright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ListaTipos listaCampos_B = (ListaTipos)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 

           if (listaCampos == null){
            listaCampos = new ListaTipos();
           }

           if (listaCampos_B != null){
            listaCampos.addLista(listaCampos_B);
           }
            RESULT = listaCampos;

          
              CUP$parser$result = parser.getSymbolFactory().newSymbol("camporeg",5, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // camporeg ::= camporegB 
            {
              ListaTipos RESULT =null;
		int listaCampos_Bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int listaCampos_Bright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ListaTipos listaCampos_B = (ListaTipos)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
             ListaTipos listaCampos;

             if (listaCampos_B == null) {
                listaCampos = new ListaTipos();
             }else{
                listaCampos = new ListaTipos(listaCampos_B);
             }
            RESULT = listaCampos;

            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("camporeg",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // tipo ::= STRUCT ID OBRACE camporeg CBRACE 
            {
              Object RESULT =null;
		int idregleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idregright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token idreg = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int listaCamposleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int listaCamposright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		ListaTipos listaCampos = (ListaTipos)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
     // Identificar si el simbolo esta utilizado por constante
     String nombre = idreg.getLexema();
     ScopeIF scope = scopeManager.getCurrentScope();
     SymbolTableIF tabla_hija = scope.getSymbolTable();

      if(tabla_hija.containsSymbol(nombre))
        {  semanticErrorManager.semanticFatalError(SemanticErrors.Simbolo_utilizado_constante, idreg); }

    	TypeRecord tipoRegistro = new TypeRecord(scope, idreg.getLexema());

      if (!tablaTipos.addType(tipoRegistro))
        {  semanticErrorManager.semanticFatalError(SemanticErrors.Tipo_duplicado, idreg); }

		  // Comprobar que los campos de registro no se repiten

      int desplReg=0;
      for (int i = listaCampos.size()-1; i>=0 ;i--){
            CampoReg c = (CampoReg) listaCampos.get(i);
            SymbolVariable var = (SymbolVariable) c.getSimbolo();
            var.setDesplazamiento(desplReg);
        desplReg++;
        if (!tipoRegistro.contieneCampo(c.getNombre()) ){
          tipoRegistro.addCampos(c.getNombre(), var);
          //Si el campo es de tipo registro comprobamos nivel de anidamiento
          TypeIF tipo = var.getType();
          if (tipo instanceof TypeRecord){
            HashMap<String, SymbolIF> campos_registro = ((TypeRecord)tipo).getCamposTabla();
            for(Map.Entry<String, SymbolIF> entry : campos_registro.entrySet()){
              if (entry.getValue().getType() instanceof TypeRecord){
                semanticErrorManager.semanticFatalError(SemanticErrors.Nivel_anidamiento_excedido, idreg);
              }
            }
          }
        } else{
                semanticErrorManager.semanticFatalError(SemanticErrors.Campo_ya_declarado, idreg);
               }
      }
      tipoRegistro.setSize(desplReg);
  
              CUP$parser$result = parser.getSymbolFactory().newSymbol("tipo",4, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // dectipos ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("dectipos",8, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // dectipos ::= tipo dectipos 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("dectipos",8, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // constante ::= CONSTANT ID NUM SEMICOLON 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int naturalleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int naturalright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token natural = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
				String   nombre = id.getLexema();
				SymbolIF simbolo = null;
				Integer miConstante = null;

        miConstante = new Integer(Integer.valueOf(natural.getLexema()).intValue());
        simbolo = new SymbolConstantInteger(nombre, miConstante);

          if(!tablaSimbolos.addSymbol(simbolo))
          { semanticErrorManager.semanticFatalError(SemanticErrors.Simbolo_constante_declarada, id); }

			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("constante",2, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // decconstantes ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("decconstantes",3, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // decconstantes ::= constante decconstantes 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("decconstantes",3, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // axiom ::= NT$1 decconstantes dectipos decvariables decfunciones 
            {
              Axiom RESULT =null;
              // propagate RESULT from NT$1
                RESULT = (Axiom) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int dvleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int dvright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		DeclaracionVariables dv = (DeclaracionVariables)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int axleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int axright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Subprogramas ax = (Subprogramas)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
        
           // Código FINAL (esto por ahora no )
           ActivaMemoria.mapeo();
           int direccion = ActivaMemoria.getDireccionSiguinteGlobal();
           // fin código final

            // Código intermedio
            ScopeIF scope = scopeManager.getCurrentScope();
            Variable var = new Variable(scopeManager.getCurrentScope().getName(),scope);

            desplazaScope.put(scopeManager.getCurrentScope().getName(), scope);
            var.setTablaDesplazamiento(desplazaScope);

            // Crear el array de Código intermedio de todo el árbol sintáctico
            IntermediateCodeBuilder iCB = new IntermediateCodeBuilder(scope);
            // cuadrupla inicio de programa
            iCB.addQuadruple("INIT", new Value(direccion), ax.getLabel());
            // Se añaden él resto de cláusulas
            iCB.addQuadruples(ax.getIntermediateCode());
            // cuadrupla final de programa
            iCB.addQuadruple("HALT");
            ax.setIntermediateCode(iCB.create());

            // *************** MOSTRAR CUADRUPLAS DEGUGGER ************************                              
/*            String cuadruplas = "";
             List<QuadrupleIF> intermediateCode = ax.getIntermediateCode();
              for(QuadrupleIF q : intermediateCode)
              {
                  cuadruplas += q.toString() + "\n";
              }
             semanticErrorManager.semanticDebug ("[Cuadruplas]  \n" + cuadruplas);*/
            // *************** MOSTRAR CUADRUPLAS DEGUGGER ************************   

              RESULT=ax;

            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("axiom",1, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // NT$1 ::= 
            {
              Axiom RESULT =null;

           String nombre = "global";
           ScopeIF scope = scopeManager.openScope(nombre);
           TypeTableIF typeTable = scope.getTypeTable();
           
           //Declaramos tipos Simples
           // Entero (int)
           TypeSimple entero = new TypeInteger(scope,"Integer");
           typeTable.addType("int", entero);
           
           // Vacío (void)
           TypeSimple vacio = new TypeVoid(scope,"void");
           typeTable.addType("void", vacio);

          // Fin declaración tipos simples
           System.out.println("[TIPOS simples] "+ scope.getTypeTable());

           
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$1",35, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // program ::= NT$0 axiom 
            {
              Object RESULT =null;
              // propagate RESULT from NT$0
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int axleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int axright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Axiom ax = (Axiom)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
      // No modificar esta estructura, aunque se pueden añadir más acciones semánticas
      
     // Se ha cambiado esta linea 
     // List<QuadrupleIF> intermediateCode = ax.getIntermediateCode ();
     // por esta otra
     List intermediateCode = ax.getIntermediateCode ();

    // Para el código final activar
    finalCodeFactory.setEnvironment(CompilerContext.getExecutionEnvironment());
    finalCodeFactory.create (intermediateCode);
    // fin del código final

      // En caso de no comentarse las sentencias anteriores puede generar una excepcion
      // en las llamadas a cupTest si el compilador no está completo. Esto es debido a que 
      // aún no se tendrá implementada la generación de código intermedio ni final.
      // Para la entrega final deberán descomentarse y usarse.
      
      syntaxErrorManager.syntaxInfo ("Parsing process ended.");
  
              CUP$parser$result = parser.getSymbolFactory().newSymbol("program",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // NT$0 ::= 
            {
              Object RESULT =null;
 syntaxErrorManager.syntaxInfo ("Starting parsing..."); 
	
  
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$0",34, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= program EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		RESULT = start_val;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$parser$parser.done_parsing();
          return CUP$parser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

